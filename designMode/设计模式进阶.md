# 设计模式进阶

面向对象的四个基本原则：封装，抽象，继承，多条



**设计原则**

面向对象的设计原则被称为SOLID，包括

- 单一职责原则：类的设计应当只负责本类负责的部分

- 开闭原则：代码设计对修改关闭，对扩展开放

- 里氏替换原则：派生类应该像其父类一样表现

- 接口隔离原则：客户端不应该依赖其不需要的接口

- 依赖倒置原则：高级模块与低级模块都依赖于抽象，细节依赖于抽象





## 创建型模式

### 单例模式

提前加载（饿汉式）

延迟加载（懒汉式）

**提前加载**

提前加载的单例模式直接在static属性new对象即可，由于static代码段在类创建时就会创建对象，因此保证了只会被创建一次

```java
public class Singleton {

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        System.out.println("单例模式(提前加载)："+instance);
    }


    //由于类加载的特性，static属性只会加载一次，因此static属性的对象也是唯一的
    private static Singleton instance = new Singleton();

    private Singleton(){}
    
    public static Singleton getInstance(){
        return instance;
    }

}
```



**延迟加载**

延迟加载就需要保证多线程场景下的单例

new对象时必须保证只有一个线程进入创建单例

使用**双重检查机制**来保证单例唯一性

- 第一个if是为了判断是否需要让线程获取锁
- 获取完锁后进入同步代码块，再进入if判断一次单例是否被其它线程创建过

```java
public class DelaySingleton {

    public static void main(String[] args) {
        DelaySingleton instance = DelaySingleton.getInstance();
        System.out.println("单例模式(延迟加载)："+instance);
    }

    //全局单例
    private static DelaySingleton instance;

    //私有构造方法
    private DelaySingleton(){}

    //双重检查保证多线程下的单例唯一性
    public static DelaySingleton getInstance() {
        if (instance == null){
            synchronized (DelaySingleton.class){
                if (instance == null){
                    instance = new DelaySingleton();
                }
            }
        }
        return instance;
    }
}
```





### 工厂模式

工厂模式的出现是为了抽离类中对象实例化部分的逻辑，使得类能更好的遵循单一职责原则。同时在新增子类时，也不需要重新修改创建实例的代码，创建新类型的逻辑交给了工厂负责，遵循了开闭原则。



**工厂模式分类**

简单工厂模式

- 静态工厂
- 反射工厂
- 实例工厂

抽象工厂模式

- 工厂方法模式
- 抽象工厂



> 工厂模式的具体实现方法有很多种，有时候我们可以根据场景需要灵活选择不同的实现方案来设计工厂模式，因此工厂模式并不存在非常严格的规定和准则。
>
> 我们需要知道的是工厂模式的**核心**就是由工厂类来负责合适对象的创建。



**产品类**

```java
public interface Product {

    String getName();
    
    Product newInstance();
    
}
```

```java
public class ProductA implements Product{
    @Override
    public String getName() {
        return "产品A";
    }

    @Override
    public Product newInstance() {
        return new ProductA();
    }
}
```

```java
public class ProductB implements Product{
    @Override
    public String getName() {
        return "产品B";
    }

    @Override
    public Product newInstance() {
        return new ProductB();
    }
}
```

```java
public class ProductC implements Product{
    @Override
    public String getName() {
        return "产品C";
    }

    @Override
    public Product newInstance() {
        return new ProductC();
    }
}
```



**简单工厂**

简单工厂只需要客户提供指明对象类型的参数，即可实例化具体的产品返回，返回的产品转换为基类型。

**1.静态工厂**

下面是一个最简单的静态工厂实现，但是如果需要一个新的产品类型D，我们就需要修改工厂代码，这**打破了开闭原则**，因此我们需要改进该静态工厂。

```java
public class SimpleStaticFactory {
    
    public enum ProductType{
        A,B,C
    }
    
    public static Product create(ProductType productType){
        if (productType.equals(ProductType.A)){
            return new ProductA();
        }
        else if (productType.equals(ProductType.B)){
            return new ProductB();
        }
        else if (productType.equals(ProductType.C)){
            return new ProductC();
        }
        return null;
    }
    
}
```



**2.反射工厂**

反射工厂模式需要运行时权限，因此在某些特定环境是无法实现的。同时反射机制也会降低程序的效率，在对性能要求很高的场景应该避免这种用法。

```java
public class ClassFactory {

    public static void main(String[] args) {
        ClassFactory classStaticFactory = new ClassFactory();
        //向静态工厂注册子类型
        classStaticFactory.registerProduct("A", ProductA.class);
        classStaticFactory.registerProduct("B", ProductB.class);
        classStaticFactory.registerProduct("C", ProductC.class);

        try {//创建实例
            Product a = classStaticFactory.create("A");
            Product b = classStaticFactory.create("B");
            Product c = classStaticFactory.create("C");
            System.out.println("简单工厂(反射):"+ a.getName());
            System.out.println("简单工厂(反射):"+ b.getName());
            System.out.println("简单工厂(反射):"+ c.getName());
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }
    }

    private Map<String,Class> registeredProducts = new HashMap<>();

    //向工厂注册一种新的类型
    public void registerProduct(String productId,Class<? extends Product> productClass){
        registeredProducts.put(productId,productClass);
    }

    //通过反射动态创建类的实例
    public Product create(String productId) throws IllegalAccessException, InstantiationException {
        Class productClass = registeredProducts.get(productId);
        return (Product) productClass.newInstance();
    }


}
```



**3.使用newInstance方法进行类注册的简单工厂**

这种工厂的特点是提前注册，将子类的一个**实例副本**保存到集合中，同时所有子类需要实现一个`newInstance()`来创建当前类的实例。工厂通过调用子类的`newInstance()`方法来动态的创建子类实例。

```java
import java.util.HashMap;
import java.util.Map;

public class NewInstanceFactory {

    public static void main(String[] args) {
        NewInstanceFactory newInstanceStaticFactory = new NewInstanceFactory();
        //向工厂注册子类型
        newInstanceStaticFactory.registerProduct("A", new ProductA());
        newInstanceStaticFactory.registerProduct("B", new ProductB());
        newInstanceStaticFactory.registerProduct("C", new ProductC());

        Product a = newInstanceStaticFactory.create("A");
        Product b = newInstanceStaticFactory.create("B");
        Product c = newInstanceStaticFactory.create("C");
        System.out.println("简单工厂(实例):"+ a.getName());
        System.out.println("简单工厂(实例):"+ b.getName());
        System.out.println("简单工厂(实例):"+ c.getName());
    }

    private Map<String,Product> registeredProducts = new HashMap<>();

    //向工厂注册新的实例
    public void registerProduct(String productId,Product product){
        registeredProducts.put(productId,product);
    }

    //通过保存的实例创建新的实例
    public Product create(String productId){
        Product product = registeredProducts.get(productId);
        if (product != null){
            return product.newInstance();
        }
        return null;
    }


}
```



**抽象工厂模式**

抽象工厂模式要求**产品和工厂**都是面向抽象类或接口的，每一个产品都有其父类，且交由具体的工厂实例化，所有具体的工厂都实现了抽象工厂类。

**1.传统工厂方法模式**

工厂方法模式是抽象工厂模式的特例，即只存在一个抽象产品类。通过一个抽象的工厂类提供创建实例的抽象方法，其创建实例的逻辑应交由具体的子类工厂方法实现。也就是如果我们需要一个新的产品加入工厂，需要继承抽象工厂并实现对应的创建方法，这**遵循了开闭原则**。

> 传统工厂方法模式就是只有一种抽象产品的抽象工厂

**2.匿名工厂方法**

匿名工厂方法即将抽象工厂类的具体实现通过匿名类的形式写在代码块中，同样遵循了开闭原则。

```java
public abstract class ProductFactory {

    public static void main(String[] args) {
        //创建子类工厂
        ProductFactory productAFactory = new ProductAFactory();
        Product a = productAFactory.create();
        System.out.println("工厂方法模式:"+a.getName());

        //匿名具体工厂方法模式，创建实例C
        ProductFactory productBFactory = new ProductFactory() {
            @Override
            protected Product create() {
                return new ProductB();
            }
        };

        Product b = productBFactory.create();
        System.out.println("匿名具体工厂方法模式:"+b.getName());

    }

    //抽象方法，将具体创建实例的逻辑交由具体工厂类实现
    protected abstract Product create();

}
```

具体的工厂类

```java
public class ProductAFactory extends ProductFactory{

    @Override
    protected Product create() {
        return new ProductA();
    }

}
```



**3.抽象工厂模式**

抽象工厂模式是工厂方法模式的拓展，如果说工厂方法模式中只包含一个抽象产品类，那么抽象工厂模式则包含多个抽象产品类。

抽象工厂模式中，每个**抽象产品**都有一个**抽象实例化方法**，具体的产品类将交由具体工厂实现每个产品的实例化方法。

**抽象工厂模式组成部分**

- `AbstractFactory`（抽象工厂类）：抽象类，用于声明创建不同类型产品的方法
- `ConcreteFactory`（具体工厂类）：具体类，用于实现抽象工厂中声明的方法
- `AbstractProduct` （抽象产品类）：抽象类或接口，一簇相关的产品类由来自不同层级的相似产品类组成。ProductA1和ProductB1来自第一个类簇，由ConcreteFactory1实例化。ProductA2和ProductB2来自第二个类簇，由ConcreteFactory2实例化。

> 抽象工厂模式使得产品和工厂都依赖了抽象，抽象工厂类只关心一系列抽象的产品，**不关心具体的产品是什么**，也**不关心如何生产产品**。

```java
public abstract class AbstractFactory {

    public static void main(String[] args) {

        //创建具体工厂1
        AbstractFactory factory1 = new ConcreteFactory1();
        AbstractProductA productA1 = factory1.createProductA();
        AbstractProductB productB1 = factory1.createProductB();

        System.out.println("factory1创建的具体产品:"+productA1.getName());
        System.out.println("factory1创建的具体产品:"+productB1.getName());

        //创建具体工厂2
        AbstractFactory factory2 = new ConcreteFactory2();
        AbstractProductA productA2 = factory2.createProductA();
        AbstractProductB productB2 = factory2.createProductB();

        System.out.println("factory2创建的具体产品:"+productA2.getName());
        System.out.println("factory2创建的具体产品:"+productB2.getName());
    }

    protected abstract AbstractProductA createProductA();

    protected abstract AbstractProductB createProductB();


}

abstract class AbstractProductA {

    protected abstract String getName();

}

abstract class AbstractProductB {

    protected abstract String getName();

}

class ConcreteFactory1 extends AbstractFactory {


    @Override
    protected AbstractProductA createProductA() {
        return new ProductA1();
    }

    @Override
    protected AbstractProductB createProductB() {
        return new ProductB1();
    }
}

class ConcreteFactory2 extends AbstractFactory{

    @Override
    protected AbstractProductA createProductA() {
        return new ProductA2();
    }

    @Override
    protected AbstractProductB createProductB() {
        return new ProductB2();
    }
}

class ProductA1 extends AbstractProductA {

    @Override
    protected String getName() {
        return "产品A1";
    }
}

class ProductA2 extends AbstractProductA {

    @Override
    protected String getName() {
        return "产品A2";
    }
}

class ProductB1 extends AbstractProductB {

    @Override
    protected String getName() {
        return "产品B1";
    }
}

class ProductB2 extends AbstractProductB {

    @Override
    protected String getName() {
        return "产品B2";
    }
}
```



### 建造者模式

如果一个对象有多种实例化形式，最直接的方法就是构建多个构造函数，按照不同场景进行实例化，但缺少可读性和灵活性，因此不是最佳方案。

建造者模式的目的旨在对一个复杂对象的实例化操作逻辑分别进行封装，这些类就被称为建造者。每当需要**来自同一个类但具有不同结构的对象时**，就可以通过构造另一个建造者来进行实例化。

> 当需要不同结构的对象时，我们可以通过添加新的建造者，从而实现对修改的关闭对拓展的开放



**建造者模式组成部分**

- `Product`（产品类）：需要为其构建对象的类，是具有不同表现形式的复杂或复合对象
- `Builder` （抽象建造者类）：用于声明构建产品类的组成部分的抽象类或接口，它的作用是仅公开构建产品类的功能，隐藏产品类的其它功能。（**将产品类和构建产品类的其它类分离开**）
- `ConcreteBuilder` （具体建造者类）：用于实现抽象建造者类接口中声明的方法，通过`getResult()`方法返回构建好的产品类
- `Director`（导演类）：用于指导如何构建对象的类。在建造者模式的某些变体中，导演类已被移除，其角色被抽象建造者或客户端所替代。



**带有导演类的建造者模式**

**产品类**

```java
public abstract class Product {

    public abstract Double getPrice();

    public abstract String getName();

    public abstract Long getId();

    public abstract String getDesc();

    @Override
    public String toString() {
        return super.toString();
    }

}
```

```java
public class Product1 extends Product{

    private String name;

    private Long id;

    private String desc;

    private Double price;

    public void addName(String name) {
        this.name = name;
    }

    public void addId(Long id) {
        this.id = id;
    }

    public void addDesc(String desc) {
        this.desc = desc;
    }

    public void addPrice(Double price) {
        this.price = price;
    }

    @Override
    public Double getPrice() {
        return price;
    }

    public String getName() {
        return name;
    }

    public Long getId() {
        return id;
    }

    public String getDesc() {
        return desc;
    }


    @Override
    public String toString() {
        return "Product1{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", desc='" + desc + '\'' +
                ", price=" + price +
                '}';
    }
}
```

```java
public class Product2 extends Product{

    private String name;

    private Long id;

    private String desc;

    private Double price;

    public void addName(String name) {
        this.name = name;
    }

    public void addId(Long id) {
        this.id = id;
    }

    public void addDesc(String desc) {
        this.desc = desc;
    }

    public void addPrice(Double price) {
        this.price = price;
    }

    @Override
    public Double getPrice() {
        return price;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Long getId() {
        return id;
    }

    @Override
    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Product2{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", desc='" + desc + '\'' +
                ", price=" + price +
                '}';
    }
}
```

**建造者类**

```java
public interface ProductBuilder {

    void buildProduct();

    void addName(String name);

    void addId(Long id);

    void addDesc(String desc);

    void addPrice(Double price);

    Product getProduct();
}
```

```
public class Product1Builder implements ProductBuilder{

    private Product1 product;

    @Override
    public void buildProduct() {
      product = new Product1();
    }

    @Override
    public void addName(String name) {
        product.addName(name);
    }

    @Override
    public void addId(Long id) {
        product.addId(id);
    }

    @Override
    public void addDesc(String desc) {
        product.addDesc(desc);
    }

    @Override
    public void addPrice(Double price) {
        product.addPrice(price);
    }

    @Override
    public Product getProduct() {
        return product;
    }
}
```

```java
public class Product2Builder implements ProductBuilder{

    private Product2 product;

    @Override
    public void buildProduct() {
      product = new Product2();
    }

    @Override
    public void addName(String name) {
        product.addName(name);
    }

    @Override
    public void addId(Long id) {
        product.addId(id);
    }

    @Override
    public void addDesc(String desc) {
        product.addDesc(desc);
    }

    @Override
    public void addPrice(Double price) {
        product.addPrice(price);
    }

    @Override
    public Product getProduct() {
        return product;
    }
}
```

**Director类**

```java
public class ProductBuilderDirector {


    public static void main(String[] args) {
        ProductBuilderDirector director = new ProductBuilderDirector();

        Product product1 = director.buildProduct1(new Product1Builder());
        Product product2 = director.buildProduct2(new Product2Builder());

        System.out.println("director协助下完成product1的构建:"+product1);
        System.out.println("director协助下完成product2的构建:"+product2);
    }

    public Product buildProduct1(ProductBuilder builder) {
        builder.buildProduct();
        builder.addId(System.currentTimeMillis());
        builder.addName("product-1");
        builder.addDesc("product-1 version 1.0");
        builder.addPrice(3.5D);
        return builder.getProduct();
    }

    public Product buildProduct2(ProductBuilder builder) {
        builder.buildProduct();
        builder.addId(System.currentTimeMillis());
        builder.addName("product-2");
        builder.addDesc("product-2 version 1.0");
        builder.addPrice(8.5D);
        return builder.getProduct();
    }


}
```



**问题思考**

在建造者模式中，如果产品1和产品2的结构不同，它们对应的具体建造者类的方法也会不同。在这种情况下，可以考虑以下几种设计选择：

1. **在抽象建造者类中声明所有方法**：这种方式可以让`Director`类统一使用抽象建造者来构建产品，但是这样做会导致一些方法在某些具体建造者中是不必要的。例如，产品2的建造者可能不需要实现`addPart1`方法。这种设计具有侵入性，因为它要求所有具体建造者类都必须实现抽象建造者中定义的所有方法。
2. **使用接口隔离原则**：可以为每个不同的产品建造者定义不同的接口，这样每个建造者只需要实现它们真正需要的方法。这样做可以减少侵入性，但是`Director`类在使用时需要知道具体的建造者类型，这可能会增加使用的复杂性。
3. **使用可选的方法实现**：在抽象建造者类中声明所有方法，但是提供一个默认的空实现（例如，在Java中可以使用接口的默认方法）。这样，具体建造者类可以选择性地覆盖它们需要的方法。这种方式既保持了`Director`类的统一性，又减少了对具体建造者的侵入性。
4. **不在抽象建造者中声明特定方法**：如果`addPart1`和`addPart2`方法是特定于具体建造者的，那么它们不应该在抽象建造者中声明。`Director`类可以通过其他方式来指导建造过程，例如通过使用工厂模式来获取正确的建造者实例。



**具有方法链的匿名建造者**

这是一种建造者模式的实现方式，方法链即链式调用，就是通过返回当前对象(this)来继续调用其本身。

下面通过将对象的构造者类构造为内部类的方式进行使用。

```java
public class UseExample {

    public static void main(String[] args) {
        Product product = new Product.Builder()
                .setName("product-1")
                .setDesc("description for product-1")
                .setPrice(2.9D)
                .setType("type-1")
                .setVersion("version 1.0")
                .build();

        System.out.println(product);
    }
    
}
```

```java
public class Product {

    public static class Builder{

        private Product product = new Product();

        public Builder setName(String name){
            product.setName(name);
            return this;
        }

        public Builder setDesc(String desc){
            product.setDesc(desc);
            return this;
        }

        public Builder setPrice(Double price){
            product.setPrice(price);
            return this;
        }

        public Builder setType(String type){
            product.setType(type);
            return this;
        }

        public Builder setVersion(String version){
            product.setVersion(version);
            return this;
        }

        public Product build(){
            return product;
        }

    }

    private String name;

    private String desc;

    private Double price;

    private String type;

    private String version;

    private Product(){}

    private void setName(String name) {
        this.name = name;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    @Override
    public String toString() {
        return "Product{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                ", price=" + price +
                ", type='" + type + '\'' +
                ", version='" + version + '\'' +
                '}';
    }
}
```
