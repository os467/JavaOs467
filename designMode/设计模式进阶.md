# 设计模式进阶

面向对象的四个基本原则：封装，抽象，继承，多条



**设计原则**

面向对象的设计原则被称为SOLID，包括

- 单一职责原则：类的设计应当只负责本类负责的部分

- 开闭原则：代码设计对修改关闭，对扩展开放

- 里氏替换原则：派生类应该像其父类一样表现

- 接口隔离原则：客户端不应该依赖其不需要的接口

- 依赖倒置原则：高级模块与低级模块都依赖于抽象，细节依赖于抽象





## 创建型模式（5种）

### 单例模式

提前加载（饿汉式）

延迟加载（懒汉式）

**提前加载**

提前加载的单例模式直接在static属性new对象即可，由于static代码段在类创建时就会创建对象，因此保证了只会被创建一次

```java
public class Singleton {

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        System.out.println("单例模式(提前加载)："+instance);
    }


    //由于类加载的特性，static属性只会加载一次，因此static属性的对象也是唯一的
    private static Singleton instance = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        return instance;
    }

}
```



**延迟加载**

延迟加载就需要保证多线程场景下的单例

new对象时必须保证只有一个线程进入创建单例

使用**双重检查机制**来保证单例唯一性

- 第一个if是为了判断是否需要让线程获取锁
- 获取完锁后进入同步代码块，再进入if判断一次单例是否被其它线程创建过

```java
public class DelaySingleton {

    public static void main(String[] args) {
        DelaySingleton instance = DelaySingleton.getInstance();
        System.out.println("单例模式(延迟加载)："+instance);
    }

    //全局单例
    private static DelaySingleton instance;

    //私有构造方法
    private DelaySingleton(){}

    //双重检查保证多线程下的单例唯一性
    public static DelaySingleton getInstance() {
        if (instance == null){
            synchronized (DelaySingleton.class){
                if (instance == null){
                    instance = new DelaySingleton();
                }
            }
        }
        return instance;
    }
}
```





### 工厂模式

工厂模式的出现是为了抽离类中对象实例化部分的逻辑，使得类能更好的遵循单一职责原则。同时在新增子类时，也不需要重新修改创建实例的代码，创建新类型的逻辑交给了工厂负责，遵循了开闭原则。

工厂模式应用广泛，如Spring的bean工厂



**工厂模式分类**

简单工厂模式

- 静态工厂
- 反射工厂
- 实例工厂

抽象工厂模式

- 工厂方法模式
- 抽象工厂



> 工厂模式的具体实现方法有很多种，有时候我们可以根据场景需要灵活选择不同的实现方案来设计工厂模式，因此工厂模式并不存在非常严格的规定和准则。
>
> 我们需要知道的是工厂模式的**核心**就是由工厂类来负责合适对象的创建。



**产品类**

```java
public interface Product {

    String getName();
    
    Product newInstance();
    
}
```

```java
public class ProductA implements Product{
    @Override
    public String getName() {
        return "产品A";
    }

    @Override
    public Product newInstance() {
        return new ProductA();
    }
}
```

```java
public class ProductB implements Product{
    @Override
    public String getName() {
        return "产品B";
    }

    @Override
    public Product newInstance() {
        return new ProductB();
    }
}
```

```java
public class ProductC implements Product{
    @Override
    public String getName() {
        return "产品C";
    }

    @Override
    public Product newInstance() {
        return new ProductC();
    }
}
```



**简单工厂**

简单工厂只需要客户提供指明对象类型的参数，即可实例化具体的产品返回，返回的产品转换为基类型。

**1.静态工厂**

下面是一个最简单的静态工厂实现，但是如果需要一个新的产品类型D，我们就需要修改工厂代码，这**打破了开闭原则**，因此我们需要改进该静态工厂。

```java
public class SimpleStaticFactory {
    
    public enum ProductType{
        A,B,C
    }
    
    public static Product create(ProductType productType){
        if (productType.equals(ProductType.A)){
            return new ProductA();
        }
        else if (productType.equals(ProductType.B)){
            return new ProductB();
        }
        else if (productType.equals(ProductType.C)){
            return new ProductC();
        }
        return null;
    }
    
}
```



**2.反射工厂**

反射工厂模式需要运行时权限，因此在某些特定环境是无法实现的。同时反射机制也会降低程序的效率，在对性能要求很高的场景应该避免这种用法。

```java
public class ClassFactory {

    public static void main(String[] args) {
        ClassFactory classStaticFactory = new ClassFactory();
        //向静态工厂注册子类型
        classStaticFactory.registerProduct("A", ProductA.class);
        classStaticFactory.registerProduct("B", ProductB.class);
        classStaticFactory.registerProduct("C", ProductC.class);

        try {//创建实例
            Product a = classStaticFactory.create("A");
            Product b = classStaticFactory.create("B");
            Product c = classStaticFactory.create("C");
            System.out.println("简单工厂(反射):"+ a.getName());
            System.out.println("简单工厂(反射):"+ b.getName());
            System.out.println("简单工厂(反射):"+ c.getName());
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }
    }

    private Map<String,Class> registeredProducts = new HashMap<>();

    //向工厂注册一种新的类型
    public void registerProduct(String productId,Class<? extends Product> productClass){
        registeredProducts.put(productId,productClass);
    }

    //通过反射动态创建类的实例
    public Product create(String productId) throws IllegalAccessException, InstantiationException {
        Class productClass = registeredProducts.get(productId);
        return (Product) productClass.newInstance();
    }


}
```



**3.使用newInstance方法进行类注册的简单工厂**

这种工厂的特点是提前注册，将子类的一个**实例副本**保存到集合中，同时所有子类需要实现一个`newInstance()`来创建当前类的实例。工厂通过调用子类的`newInstance()`方法来动态的创建子类实例。

```java
import java.util.HashMap;
import java.util.Map;

public class NewInstanceFactory {

    public static void main(String[] args) {
        NewInstanceFactory newInstanceStaticFactory = new NewInstanceFactory();
        //向工厂注册子类型
        newInstanceStaticFactory.registerProduct("A", new ProductA());
        newInstanceStaticFactory.registerProduct("B", new ProductB());
        newInstanceStaticFactory.registerProduct("C", new ProductC());

        Product a = newInstanceStaticFactory.create("A");
        Product b = newInstanceStaticFactory.create("B");
        Product c = newInstanceStaticFactory.create("C");
        System.out.println("简单工厂(实例):"+ a.getName());
        System.out.println("简单工厂(实例):"+ b.getName());
        System.out.println("简单工厂(实例):"+ c.getName());
    }

    private Map<String,Product> registeredProducts = new HashMap<>();

    //向工厂注册新的实例
    public void registerProduct(String productId,Product product){
        registeredProducts.put(productId,product);
    }

    //通过保存的实例创建新的实例
    public Product create(String productId){
        Product product = registeredProducts.get(productId);
        if (product != null){
            return product.newInstance();
        }
        return null;
    }


}
```



**抽象工厂模式**

抽象工厂模式要求**产品和工厂**都是面向抽象类或接口的，每一个产品都有其父类，且交由具体的工厂实例化，所有具体的工厂都实现了抽象工厂类。

**1.传统工厂方法模式**

工厂方法模式是抽象工厂模式的特例，即只存在一个抽象产品类。通过一个抽象的工厂类提供创建实例的抽象方法，其创建实例的逻辑应交由具体的子类工厂方法实现。也就是如果我们需要一个新的产品加入工厂，需要继承抽象工厂并实现对应的创建方法，这**遵循了开闭原则**。

> 传统工厂方法模式就是只有一种抽象产品的抽象工厂

**2.匿名工厂方法**

匿名工厂方法即将抽象工厂类的具体实现通过匿名类的形式写在代码块中，同样遵循了开闭原则。

```java
public abstract class ProductFactory {

    public static void main(String[] args) {
        //创建子类工厂
        ProductFactory productAFactory = new ProductAFactory();
        Product a = productAFactory.create();
        System.out.println("工厂方法模式:"+a.getName());

        //匿名具体工厂方法模式，创建实例C
        ProductFactory productBFactory = new ProductFactory() {
            @Override
            protected Product create() {
                return new ProductB();
            }
        };

        Product b = productBFactory.create();
        System.out.println("匿名具体工厂方法模式:"+b.getName());

    }

    //抽象方法，将具体创建实例的逻辑交由具体工厂类实现
    protected abstract Product create();

}
```

具体的工厂类

```java
public class ProductAFactory extends ProductFactory{

    @Override
    protected Product create() {
        return new ProductA();
    }

}
```



**3.抽象工厂模式**

抽象工厂模式是工厂方法模式的拓展，如果说工厂方法模式中只包含一个抽象产品类，那么抽象工厂模式则包含多个抽象产品类。

抽象工厂模式中，每个**抽象产品**都有一个**抽象实例化方法**，具体的产品类将交由具体工厂实现每个产品的实例化方法。

**抽象工厂模式组成部分**

- `AbstractFactory`（抽象工厂类）：抽象类，用于声明创建不同类型产品的方法
- `ConcreteFactory`（具体工厂类）：具体类，用于实现抽象工厂中声明的方法
- `AbstractProduct` （抽象产品类）：抽象类或接口，一簇相关的产品类由来自不同层级的相似产品类组成。ProductA1和ProductB1来自第一个类簇，由ConcreteFactory1实例化。ProductA2和ProductB2来自第二个类簇，由ConcreteFactory2实例化。

> 抽象工厂模式使得产品和工厂都依赖了抽象，抽象工厂类只关心一系列抽象的产品，**不关心具体的产品是什么**，也**不关心如何生产产品**。

```java
public abstract class AbstractFactory {

    public static void main(String[] args) {

        //创建具体工厂1
        AbstractFactory factory1 = new ConcreteFactory1();
        AbstractProductA productA1 = factory1.createProductA();
        AbstractProductB productB1 = factory1.createProductB();

        System.out.println("factory1创建的具体产品:"+productA1.getName());
        System.out.println("factory1创建的具体产品:"+productB1.getName());

        //创建具体工厂2
        AbstractFactory factory2 = new ConcreteFactory2();
        AbstractProductA productA2 = factory2.createProductA();
        AbstractProductB productB2 = factory2.createProductB();

        System.out.println("factory2创建的具体产品:"+productA2.getName());
        System.out.println("factory2创建的具体产品:"+productB2.getName());
    }

    protected abstract AbstractProductA createProductA();

    protected abstract AbstractProductB createProductB();


}

abstract class AbstractProductA {

    protected abstract String getName();

}

abstract class AbstractProductB {

    protected abstract String getName();

}

class ConcreteFactory1 extends AbstractFactory {


    @Override
    protected AbstractProductA createProductA() {
        return new ProductA1();
    }

    @Override
    protected AbstractProductB createProductB() {
        return new ProductB1();
    }
}

class ConcreteFactory2 extends AbstractFactory{

    @Override
    protected AbstractProductA createProductA() {
        return new ProductA2();
    }

    @Override
    protected AbstractProductB createProductB() {
        return new ProductB2();
    }
}

class ProductA1 extends AbstractProductA {

    @Override
    protected String getName() {
        return "产品A1";
    }
}

class ProductA2 extends AbstractProductA {

    @Override
    protected String getName() {
        return "产品A2";
    }
}

class ProductB1 extends AbstractProductB {

    @Override
    protected String getName() {
        return "产品B1";
    }
}

class ProductB2 extends AbstractProductB {

    @Override
    protected String getName() {
        return "产品B2";
    }
}
```



### 建造者模式

如果一个对象有多种实例化形式，最直接的方法就是构建多个构造函数，按照不同场景进行实例化，但缺少可读性和灵活性，因此不是最佳方案。

建造者模式的目的旨在对一个复杂对象的实例化操作逻辑分别进行封装，这些类就被称为建造者。每当需要**来自同一个类但具有不同结构的对象时**，就可以通过构造另一个建造者来进行实例化。

> 当需要不同结构的对象时，我们可以通过添加新的建造者，从而实现对修改的关闭对拓展的开放

常用的建造者模式如使用`JwtBuilder`来构建token



**建造者模式组成部分**

- `Product`（产品类）：需要为其构建对象的类，是具有不同表现形式的复杂或复合对象
- `Builder` （抽象建造者类）：用于声明构建产品类的组成部分的抽象类或接口，它的作用是仅公开构建产品类的功能，隐藏产品类的其它功能。（**将产品类和构建产品类的其它类分离开**）
- `ConcreteBuilder` （具体建造者类）：用于实现抽象建造者类接口中声明的方法，通过`getResult()`方法返回构建好的产品类
- `Director`（导演类）：用于指导如何构建对象的类。在建造者模式的某些变体中，导演类已被移除，其角色被抽象建造者或客户端所替代。



**带有导演类的建造者模式**

**产品类**

```java
public abstract class Product {

    public abstract Double getPrice();

    public abstract String getName();

    public abstract Long getId();

    public abstract String getDesc();

    @Override
    public String toString() {
        return super.toString();
    }

}
```

```java
public class Product1 extends Product{

    private String name;

    private Long id;

    private String desc;

    private Double price;

    public void addName(String name) {
        this.name = name;
    }

    public void addId(Long id) {
        this.id = id;
    }

    public void addDesc(String desc) {
        this.desc = desc;
    }

    public void addPrice(Double price) {
        this.price = price;
    }

    @Override
    public Double getPrice() {
        return price;
    }

    public String getName() {
        return name;
    }

    public Long getId() {
        return id;
    }

    public String getDesc() {
        return desc;
    }


    @Override
    public String toString() {
        return "Product1{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", desc='" + desc + '\'' +
                ", price=" + price +
                '}';
    }
}
```

```java
public class Product2 extends Product{

    private String name;

    private Long id;

    private String desc;

    private Double price;

    public void addName(String name) {
        this.name = name;
    }

    public void addId(Long id) {
        this.id = id;
    }

    public void addDesc(String desc) {
        this.desc = desc;
    }

    public void addPrice(Double price) {
        this.price = price;
    }

    @Override
    public Double getPrice() {
        return price;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Long getId() {
        return id;
    }

    @Override
    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Product2{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", desc='" + desc + '\'' +
                ", price=" + price +
                '}';
    }
}
```

**建造者类**

```java
public interface ProductBuilder {

    void buildProduct();

    void addName(String name);

    void addId(Long id);

    void addDesc(String desc);

    void addPrice(Double price);

    Product getProduct();
}
```

```
public class Product1Builder implements ProductBuilder{

    private Product1 product;

    @Override
    public void buildProduct() {
      product = new Product1();
    }

    @Override
    public void addName(String name) {
        product.addName(name);
    }

    @Override
    public void addId(Long id) {
        product.addId(id);
    }

    @Override
    public void addDesc(String desc) {
        product.addDesc(desc);
    }

    @Override
    public void addPrice(Double price) {
        product.addPrice(price);
    }

    @Override
    public Product getProduct() {
        return product;
    }
}
```

```java
public class Product2Builder implements ProductBuilder{

    private Product2 product;

    @Override
    public void buildProduct() {
      product = new Product2();
    }

    @Override
    public void addName(String name) {
        product.addName(name);
    }

    @Override
    public void addId(Long id) {
        product.addId(id);
    }

    @Override
    public void addDesc(String desc) {
        product.addDesc(desc);
    }

    @Override
    public void addPrice(Double price) {
        product.addPrice(price);
    }

    @Override
    public Product getProduct() {
        return product;
    }
}
```

**Director类**

```java
public class ProductBuilderDirector {


    public static void main(String[] args) {
        ProductBuilderDirector director = new ProductBuilderDirector();

        Product product1 = director.buildProduct1(new Product1Builder());
        Product product2 = director.buildProduct2(new Product2Builder());

        System.out.println("director协助下完成product1的构建:"+product1);
        System.out.println("director协助下完成product2的构建:"+product2);
    }

    public Product buildProduct1(ProductBuilder builder) {
        builder.buildProduct();
        builder.addId(System.currentTimeMillis());
        builder.addName("product-1");
        builder.addDesc("product-1 version 1.0");
        builder.addPrice(3.5D);
        return builder.getProduct();
    }

    public Product buildProduct2(ProductBuilder builder) {
        builder.buildProduct();
        builder.addId(System.currentTimeMillis());
        builder.addName("product-2");
        builder.addDesc("product-2 version 1.0");
        builder.addPrice(8.5D);
        return builder.getProduct();
    }


}
```



**问题思考**

在建造者模式中，如果产品1和产品2的结构不同，它们对应的具体建造者类的方法也会不同。在这种情况下，可以考虑以下几种设计选择：

1. **在抽象建造者类中声明所有方法**：这种方式可以让`Director`类统一使用抽象建造者来构建产品，但是这样做会导致一些方法在某些具体建造者中是不必要的。例如，产品2的建造者可能不需要实现`addPart1`方法。这种设计具有侵入性，因为它要求所有具体建造者类都必须实现抽象建造者中定义的所有方法。
2. **使用接口隔离原则**：可以为每个不同的产品建造者定义不同的接口，这样每个建造者只需要实现它们真正需要的方法。这样做可以减少侵入性，但是`Director`类在使用时需要知道具体的建造者类型，这可能会增加使用的复杂性。
3. **使用可选的方法实现**：在抽象建造者类中声明所有方法，但是提供一个默认的空实现（例如，在Java中可以使用接口的默认方法）。这样，具体建造者类可以选择性地覆盖它们需要的方法。这种方式既保持了`Director`类的统一性，又减少了对具体建造者的侵入性。
4. **不在抽象建造者中声明特定方法**：如果`addPart1`和`addPart2`方法是特定于具体建造者的，那么它们不应该在抽象建造者中声明。`Director`类可以通过其他方式来指导建造过程，例如通过使用工厂模式来获取正确的建造者实例。



**具有方法链的匿名建造者**

这是一种建造者模式的实现方式，方法链即链式调用，就是通过返回当前对象(this)来继续调用其本身。

下面通过将对象的构造者类构造为内部类的方式进行使用。

```java
public class UseExample {

    public static void main(String[] args) {
        Product product = new Product.Builder()
                .setName("product-1")
                .setDesc("description for product-1")
                .setPrice(2.9D)
                .setType("type-1")
                .setVersion("version 1.0")
                .build();

        System.out.println(product);
    }
    
}
```

```java
public class Product {

    public static class Builder{

        private Product product = new Product();

        public Builder setName(String name){
            product.setName(name);
            return this;
        }

        public Builder setDesc(String desc){
            product.setDesc(desc);
            return this;
        }

        public Builder setPrice(Double price){
            product.setPrice(price);
            return this;
        }

        public Builder setType(String type){
            product.setType(type);
            return this;
        }

        public Builder setVersion(String version){
            product.setVersion(version);
            return this;
        }

        public Product build(){
            return product;
        }

    }

    private String name;

    private String desc;

    private Double price;

    private String type;

    private String version;

    private Product(){}

    private void setName(String name) {
        this.name = name;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    @Override
    public String toString() {
        return "Product{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                ", price=" + price +
                ", type='" + type + '\'' +
                ", version='" + version + '\'' +
                '}';
    }
}
```







### 原型模式

原型模式实际上是一种克隆对象的方法，在以下几种情况可能需要克隆已经实例化的对象

- 依赖于外部资源或硬件密集型操作进行新对象的创建的情况
- 获取相同对象在相同状态的拷贝而无须进行重复获取状态操作的情况
- 在不确定所属具体类型时需要对象的实例的情况

JavaScript的对象设计使用的就是原型模式



**原型模式组成**

`Prototype`（抽象原型类）：声明了`clone()`方法的接口或基类，其中`clone()`方法必须由派生对象实现，在简单场景中，并不需要这种基类，只需要具体的类即可

`ConcretePrototype`（具体原型类）：用于实现或扩展`clone`方法的类，`clone`方法**必须要实现**，因为它返回了类型的新实例。如果只在基类中实现了clone方法，却没在具体类中实现，那么当我们在具体原型类的对象上调用该方法时，会返回一个基类的抽象原型对象



**浅拷贝和深拷贝**

浅拷贝是指复制对象的属性值，如果遇到引用对象也只是复制地址

深拷贝则是在复制值的同时如果遇到引用对象，也要对引用对象进行深拷贝



> Object作为抽象原型类,在Java语言中,所有的类都是Object的子类,在Object 中提供了克隆方法clone(),用于创建一个原型对象,其 clone()方法具体实现由JVM完成,用户在使用时无须关心。



**浅拷贝原型模式**

在Java中只有实现了Cloneable接口的类才能够使用clone()方法来进行复制，因此我们需要实现Cloneable。

```java
public class ConcretePrototype implements Cloneable {

    public static void main(String[] args) {

        ConcretePrototype concretePrototype = new ConcretePrototype();

        try {
            ConcretePrototype prototype = (ConcretePrototype) concretePrototype.clone();

            System.out.println("是否新对象:"+ (prototype != concretePrototype) );

            System.out.println("是否浅拷贝:"+ (prototype.attachment == concretePrototype.attachment) );

            System.out.println(prototype);
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

    }

    private int anInt = 1;

    private double aDouble = 2.2f;

    private String string = "str";

    private Attachment attachment = new Attachment();

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "ConcretePrototype{" +
                "anInt=" + anInt +
                ", aDouble=" + aDouble +
                ", string='" + string + '\'' +
                ", attachment=" + attachment +
                '}';
    }
}

class Attachment{

    private String str = "attachment";

    private boolean aBoolean = false;

    @Override
    public String toString() {
        return "Attachment{" +
                "str='" + str + '\'' +
                ", aBoolean=" + aBoolean +
                '}';
    }
}
```





**深拷贝原型模式**

通常java中我们可以通过序列化和反序列化来深拷贝一个对象，属性中需要序列化的类都要实现**Serializable接口**，不需要序列化拷贝的属性可以使用transient关键字，这样拷贝到的就是null

```java
import java.io.*;

public class DeepCloneConcretePrototype implements Serializable {

    private static final long serialVersionUID = 1236212586122492189L;

    public static void main(String[] args) {

        DeepCloneConcretePrototype deepCloneConcretePrototype = new DeepCloneConcretePrototype();

        DeepCloneConcretePrototype prototype = null;
        try {
            prototype = deepCloneConcretePrototype.deepClone();
        } catch (IOException ioException) {
            ioException.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        System.out.println("是否新对象:"+ (prototype != deepCloneConcretePrototype) );

        System.out.println("是否深拷贝:"+ (prototype.attachment != deepCloneConcretePrototype.attachment) );

        System.out.println(prototype);

    }

    private DeepCloneConcretePrototype deepClone() throws IOException, ClassNotFoundException {
        //序列化
        ByteArrayOutputStream bao = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bao);
        oos.writeObject(this);

        //反序列化
        ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return (DeepCloneConcretePrototype)ois.readObject();
    }

    private int anInt = 1;

    private double aDouble = 2.2f;

    private String string = "str";

    private DeepCloneAttachment attachment = new DeepCloneAttachment();

    @Override
    public String toString() {
        return "DeepCloneConcretePrototype{" +
                "anInt=" + anInt +
                ", aDouble=" + aDouble +
                ", string='" + string + '\'' +
                ", attachment=" + attachment +
                '}';
    }
}

class DeepCloneAttachment implements Serializable{

    private String str = "attachment";

    private boolean aBoolean = false;

    @Override
    public String toString() {
        return "DeepCloneAttachment{" +
                "str='" + str + '\'' +
                ", aBoolean=" + aBoolean +
                '}';
    }
}
```





### 对象池模式

当我们处理封装外部资源的对象（如数据库连接）时，对象的创建造作会耗费很多资源

解决方案是重用和共享这些创建成本高昂的对象，这被称为对象池模式



**对象池模式组成部分**

- `ResourcePool`（资源池类）：用于封装逻辑的类，用来保存和管理资源列表
- `Resource`（资源类）：用于封装特定资源的类，资源类通常被资源池类引用，因此只要资源池不重新分配，它们就永远不会被回收
- `Client` （客户端类）：使用资源的类



当客户端需要使用资源时，会向资源池类申请，资源池类检查后获取第一个可用资源并将其返回给客户端

客户端使用完资源后会释放资源，资源会重新回到资源池以便重复使用



**资源池类**

```java
import java.util.ArrayList;
import java.util.List;

public class ResourcePool {

    //可用资源列表
    private List<Resource> available = new ArrayList<>();

    //当前资源池创建被投入使用的资源列表
    private List<Resource> inuse = new ArrayList<>();

    //客户端获取资源
    public Resource acquireResource(){
        if (available.size() <= 0){
            Resource resource = new Resource(this);
            inuse.add(resource);
            return resource;
        }else {
            //返回第一个可用资源
            return available.remove(0);
        }
    }

    //客户端释放资源
    public void releaseResource(Resource resource) {
        available.add(resource);
    }
}
```

**资源类**

```java
public class Resource {

    private ResourcePool resourcePool;

    public Resource(ResourcePool resourcePool) {
        this.resourcePool = resourcePool;
    }

    //资源释放方法
    public void release(){
        resourcePool.releaseResource(this);
    }

}
```

**客户端类**

```java
public class Client {

    public static void main(String[] args) {

        ResourcePool resourcePool = new ResourcePool();
        Resource resource = resourcePool.acquireResource();

        System.out.println("当前使用资源:"+resource);

        System.out.println("释放资源");
        resource.release();

        Resource resource1 = resourcePool.acquireResource();

        System.out.println("当前使用资源:"+resource1);

        Resource resource2 = resourcePool.acquireResource();

        System.out.println("当前使用资源:"+resource2);

    }

}
```



## 行为型模式（12种）

### 责任链模式

设想一个场景，需要对一批从客户端来的数据进行多种不同的操作，我们会使用多个不同的类负责不同的操作，而不是用一个类集成所有操作，这样做能让代码松耦合且简洁。

这些类被称为**处理器**，责任链模式让处理器按以下方式处理：如果需要则处理请求，否则将请求传递给下一个处理器。



**责任链模式组成部分**

- `Client`（客户端）：客户端是使用责任链模式的应用程序的主要结构，它的职责是实例化一个处理器的链，然后在第一个对象中调用`handleRequest`方法
- `Handler`（处理器）：这是一个抽象类，提供给所有实际处理器进行继承。它拥有一个`handleRequest`方法，用来接收需要处理的请求
- `ConcreteHandler`（具体处理器）：这是一个实现了`handleRequest`方法的具体类。每一个具体处理器都维持一个引用，指向链中下一个具体处理器，需要检查它自身是否能处理这个请求，不能就将请求传递给链中的下一个具体处理器。



**链表式的责任链模式**

每一个处理器需要实现一个方法，该方法被客户端所使用，并能够设置下一个处理器，当它无法处理请求时，将请求传给下一个处理器，这个方法可以加入到`Handler`基类中

**处理器接口**

```java
public interface Handler {

    void handleRequest(Request request);

    void setNextHandler(Handler handler);

}
```

**具体处理器类**

```java
public class ConcreteHandler1 implements Handler {

    private Handler handler;

    @Override
    public void handleRequest(Request request) {
        if (canHandle(request)){
            //处理请求
            System.out.println(request.getName());
        }else {
            handler.handleRequest(request);
        }
    }

    private boolean canHandle(Request request) {
        if (request.getName().equals("请求类型1")){
            return true;
        }
        return false;
    }

    @Override
    public void setNextHandler(Handler handler) {
        this.handler = handler;
    }
}
```

```java
public class ConcreteHandler2 implements Handler {

    private Handler handler;

    @Override
    public void handleRequest(Request request) {
        if (canHandle(request)){
            //处理请求
            System.out.println(request.getName());
        }else {
            handler.handleRequest(request);
        }
    }

    private boolean canHandle(Request request) {
        if (request.getName().equals("请求类型2")){
            return true;
        }
        return false;
    }

    @Override
    public void setNextHandler(Handler handler) {
        this.handler = handler;
    }
}
```

```java
public class ConcreteHandler3 implements Handler {

    private Handler handler;

    @Override
    public void handleRequest(Request request) {
        if (canHandle(request)){
            //处理请求
            System.out.println(request.getName());
        }else {
            handler.handleRequest(request);
        }
    }

    private boolean canHandle(Request request) {
        if (request.getName().equals("请求类型3")){
            return true;
        }
        return false;
    }

    @Override
    public void setNextHandler(Handler handler) {
        this.handler = handler;
    }
}
```

**请求类**

```java
public class Request {

    private String name;

    public Request(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

**客户端类**

```java
public class Client {

    public static void main(String[] args) {

        //创建具体处理器
        ConcreteHandler1 handler1 = new ConcreteHandler1();
        ConcreteHandler2 handler2 = new ConcreteHandler2();
        ConcreteHandler3 handler3 = new ConcreteHandler3();
        //设置责任链
        handler1.setNextHandler(handler2);
        handler2.setNextHandler(handler3);

        //处理请求
        handler1.handleRequest(new Request("请求类型1"));
        handler1.handleRequest(new Request("请求类型2"));
        handler1.handleRequest(new Request("请求类型3"));

        //处理请求-失败
        handler1.handleRequest(new Request("请求类型100"));

    }

}
```



**问题思考**

在具体处理器3也无法处理请求时，我们直接调用下一个处理器处理请求会报出空指针异常。由于处理器3就是最后一个处理器，因此我们需要一个默认处理器来处理无法被处理的请求，这是一种比较妥善的设计方式。

默认处理器是责任链中的最后一个处理器，用于处理无法被责任链处理的任意请求。

```java
class Test{
    public static void main(String[] args){
        // 创建具体处理器
        ConcreteHandler1 handler1 = new ConcreteHandler1();
        ConcreteHandler2 handler2 = new ConcreteHandler2();
        ConcreteHandler3 handler3 = new ConcreteHandler3();
        DefaultHandler defaultHandler = new DefaultHandler(); // 创建默认处理器

        // 设置责任链
        handler1.setNextHandler(handler2);
        handler2.setNextHandler(handler3);
        handler3.setNextHandler(defaultHandler); // 将默认处理器设置为链的最后一个处理器
    }
}
```





责任链模式还有另外一种形式，可以设置责任链中处理器的优先级，并使用数组来存储处理器，通过遍历处理器数组来执行责任链逻辑，例如Servlet中的Filter就是如此设计的

```java
public final class ApplicationFilterChain implements FilterChain {
    private int pos = 0; //当前执行filter的offset
    private int n; //当前filter的数量
    private ApplicationFilterConfig[] filters;  //filter配置类，通过getFilter()方法获取Filter
    private Servlet servlet;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response) {
        if (pos < n) {
            ApplicationFilterConfig filterConfig = filters[pos++];
            Filter filter = filterConfig.getFilter();
            filter.doFilter(request, response, this);
        } else {
            // filter都处理完毕后，执行servlet
            servlet.service(request, response);
        }
    }

}
```





### 命令模式

命令模式的目的

- 提供一个统一的方法来封装命令和其所需要的参数来执行一个动作
- 允许处理命令，例如将命令存储在队列中



**命令模式组成部分**

`Command`（命令类）：这是表示命令封装的抽象类，它声明了执行的抽象方法，该方法应该由所有具体命令实现。

`ConcreteCommand`（具体命令类）：这是命令类的实际实现，它必须执行命令并处理与每个具体命令相关的参数，它将命令委托给接收者。

`Receiver`（接收者）：这是负责执行与命令关联的操作的类。

`Invoker`（调用者）：这是触发命令的类，通常是外部事件，例如用户操作。

`Client`（客户端）：这是实例化具体命令对象及其接收者的实际类。











### 解释器模式





### 迭代器模式

迭代器模式是Java中最广为认知的模式之一，Java程序员在使用Collection时，不需要关注其类型是数组，列表，集合还是其它。

我们可以以相同的方式处理集合，无论它是列表还是数组，这是因为它提供了一种迭代其元素而不暴露其内部结构的机制。更重要的是，不同类型的集合能够使用相同统一的机制，这种机制被称为迭代器模式。



> 迭代器模式提供了一种顺序遍历聚合对象元素而不暴露其内部实现的方法









## 结构型模式（7种）
